<!DOCTYPE html>
<html>

	<head>
		<script src="../stitch.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js"></script>
		<style>
			svg {
				margin: auto;
				position: absolute;
				inset: 0;
			}
		</style>
	</head>

	<body>
		<script>let shape = [
  [102, 356], [ 24, 251], [ 32, 179], [ 84, 250], [ 58, 145], [ 80, 108], [127,  46], [127, 102],
  [102, 140], [116, 164], [135, 188], [171, 151], [193, 106], [201,  73], [233,  57], [232,  86],
  [225, 112], [240, 116], [256,  94], [279,  73], [320,  85], [329, 118], [354, 173], [362, 228],
  [356, 266], [312, 211], [269, 190], [247, 206], [227, 240], [228, 262], [243, 255], [246, 233],
  [256, 218], [282, 219], [312, 246], [323, 268], [331, 301], [319, 325], [290, 356], [248, 362],
  [216, 357], [205, 337], [199, 293], [189, 246], [172, 235], [152, 245], [139, 261], [138, 283],
  [146, 277], [159, 257], [174, 256], [174, 274], [177, 302], [177, 336], [158, 358], [121, 366]
];

let contours = [
  [[142, 324], [142, 296], [121, 297], [108, 315], [125, 338]],
  [[206, 139], [194, 150], [203, 166], [217, 146]],
  [[234, 309], [234, 326], [260, 326], [286, 295], [286, 264], [254, 279]]
];

let testIndex = 0;

function setup() {
  createCanvas(400, 400);
}

function draw() {
  
  background(255);
  
  // params
  let spacing = 5;
  let angle = Stitch.Math.Vector.fromAngle(map(mouseX, 0, width, 0, PI, true));
  // angle = Stitch.Math.Vector.fromAngle(map(110, 0, width, 0, PI, true));
  // angle = Stitch.Math.Vector.fromAngle(0);
  
  // basic draw
  stroke(0);
  fill(255);
  beginShape();
  for (let point of shape) vertex(point[0], point[1]);
  for (let contour of contours) {
    beginContour();
    for (let point of contour) vertex(point[0], point[1]);
    endContour(CLOSE);
  }
  endShape(CLOSE);
  
  // calculate the bounding box
  let boundingBox = {
    min: new Stitch.Math.Vector(shape[0][0], shape[0][1]),
    max: new Stitch.Math.Vector(shape[0][0], shape[0][1])
  };
  for (let point of shape) {
    if (point[0] < boundingBox.min.x) boundingBox.min.x = point[0];
    else if (point[0] > boundingBox.max.x) boundingBox.max.x = point[0];
    if (point[1] < boundingBox.min.y) boundingBox.min.y = point[1];
    else if (point[1] > boundingBox.max.y) boundingBox.max.y = point[1];
  }
  
  // calculate the center and max distance
  let boundingBoxcenter = boundingBox.max.add(boundingBox.min).divide(2);
  let boundingBoxMaxDistance = boundingBox.min.distance(boundingBoxcenter);
  
  // create the hatch lines
  let hatchLines = [];
  for (let d = -boundingBoxMaxDistance; d <= boundingBoxMaxDistance; d += spacing) {
    hatchLines.push([
      boundingBoxcenter.add(angle.rotate(0.5 * Math.PI).multiply(d)).add(angle.multiply(boundingBoxMaxDistance)),
      boundingBoxcenter.add(angle.rotate(0.5 * Math.PI).multiply(d)).add(angle.multiply(-boundingBoxMaxDistance))
    ]);
  }
  
  // draw the hatch lines
  // for (let hatchLine of hatchLines) {
  //   line(hatchLine[0].x, hatchLine[0].y, hatchLine[1].x, hatchLine[1].y);
  // }
  
  // calculate the line segments
  let hatchLineSegmentRows = [];
  for (let [n, hatchLine] of hatchLines.entries()) {
    // get the intersections
    let intersections = [];
    for (let i = 0; i < shape.length; i++) {
      let p = new Stitch.Math.Vector(shape[i][0], shape[i][1]);
      let q = new Stitch.Math.Vector(shape[(i + 1) % shape.length][0], shape[(i + 1) % shape.length][1]);
      let intersection = Stitch.Math.Utils.lineSegmentIntersection(hatchLine[0], hatchLine[1], p, q);
      if (intersection) {
        let d = hatchLine[0].distance(intersection);
        intersections.push({ position: intersection, percent: d / (2 * boundingBoxMaxDistance) });
      }
    }
    for (let contour of contours) {
      for (let i = 0; i < contour.length; i++) {
        let p = new Stitch.Math.Vector(contour[i][0], contour[i][1]);
        let q = new Stitch.Math.Vector(contour[(i + 1) % contour.length][0], contour[(i + 1) % contour.length][1]);
        let intersection = Stitch.Math.Utils.lineSegmentIntersection(hatchLine[0], hatchLine[1], p, q);
        if (intersection) {
          let d = hatchLine[0].distance(intersection);
          intersections.push({ position: intersection, percent: d / (2 * boundingBoxMaxDistance) });
        }
      }
    }
    if (intersections.length > 0 && intersections.length % 2 === 0) {
      intersections.sort((a, b) => { return a.percent > b.percent ? 1 : -1; });
      // for (let i = intersections.length - 2; i > 0; i -= 2) {
      // 	if (intersections[i].position.distance(intersections[i - 1].position) < spacing) {
      // 		intersections.splice(i - 1, 2);
      // 	}
      // }
      let hatchLineSegmentsRow = [];
      for (let i = 0; i < intersections.length; i += 2) {
        hatchLineSegmentsRow.push({
          start: {position: intersections[i].position, percent: intersections[i].percent},
          end: {position: intersections[i + 1].position, percent: intersections[i + 1].percent}
        });
      }
      hatchLineSegmentRows.push(hatchLineSegmentsRow);
    } else {
      if (intersections.length % 2 !== 0) console.log("intersections.length % 2 !== 0");
    }
  }
  
  // draw the line segments
  if (frameCount === 1) console.log(hatchLineSegmentRows);
  stroke(180);
  for (let hatchLineSegmentRow of hatchLineSegmentRows) {
    for (let hatchLineSegment of hatchLineSegmentRow) {
      line(hatchLineSegment.start.position.x, hatchLineSegment.start.position.y, hatchLineSegment.end.position.x, hatchLineSegment.end.position.y);
      circle(0.5 * (hatchLineSegment.start.position.x + hatchLineSegment.end.position.x), 0.5 * (hatchLineSegment.start.position.y + hatchLineSegment.end.position.y), 3);
    }
  }
  
  // create the graph
  let hatchGraph = new Stitch.Math.Graph();
  for (let i = 0; i < hatchLineSegmentRows.length; i++) {
    for (let j = 0; j < hatchLineSegmentRows[i].length; j++) {
      hatchGraph.addVertex(`${i}-${j}`);
    }
  }
  for (let i = 1; i < hatchLineSegmentRows.length; i++) {
    let currHatchLineSegmentRow = hatchLineSegmentRows[i];
    let prevHatchLineSegmentRow = hatchLineSegmentRows[i - 1];
    for (let j = 0; j < currHatchLineSegmentRow.length; j++) {
      let currHatchLineSegment = currHatchLineSegmentRow[j];
      for (let k = 0; k < prevHatchLineSegmentRow.length; k++) {
        let prevHatchLineSegment = prevHatchLineSegmentRow[k];
        let sumPercentDifference = (currHatchLineSegment.end.percent - currHatchLineSegment.start.percent) + (prevHatchLineSegment.end.percent - prevHatchLineSegment.start.percent);
        if (Math.max(currHatchLineSegment.end.percent, prevHatchLineSegment.end.percent) - Math.min(currHatchLineSegment.start.percent, prevHatchLineSegment.start.percent) < sumPercentDifference) {
          hatchGraph.addEdge(`${i}-${j}`, `${i - 1}-${k}`);
        }
      }
    }
  }
  
  // // draw the graph
  // if (frameCount === 1) console.log(hatchGraph);
  // stroke(0);
  // for (let [currVertex, edgeList] of Object.entries(hatchGraph.edges)) {
  //   let currRowIndex = currVertex.split("-")[0];
  //   let currSegmentIndex = currVertex.split("-")[1];
  //   let currLineSegment = hatchLineSegmentRows[currRowIndex][currSegmentIndex];
  //   // if (edgeList.length < 3) stroke(255, 0, 0);
  //   // else {
  //   //   stroke(0);
  //   //   line(currLineSegment.start.position.x, currLineSegment.start.position.y, currLineSegment.end.position.x, currLineSegment.end.position.y);
  //   // }
  //   for (let edge of edgeList) {
  //     let nextRowIndex = edge.vertex.split("-")[0];
  //     let nextSegmentIndex = edge.vertex.split("-")[1];
  //     let nextLineSegment = hatchLineSegmentRows[nextRowIndex][nextSegmentIndex];
  //     if (nextRowIndex > currRowIndex) {
  //       let currLineSegmentMidPoint = currLineSegment.start.position.add(currLineSegment.end.position).multiply(0.5);
  //       let nextLineSegmentMidPoint = nextLineSegment.start.position.add(nextLineSegment.end.position).multiply(0.5);
  //       line(currLineSegmentMidPoint.x, currLineSegmentMidPoint.y, nextLineSegmentMidPoint.x, nextLineSegmentMidPoint.y);
  //     }
  //   }
  // }
  
  // simplify the graph
  let simplifiedHatchGraph = hatchGraph.copy();
  let nonPathVertices = [];
  for (let [vertex, edgeList] of Object.entries(hatchGraph.edges)) {
    if (edgeList.length > 2) {
    	// simplifiedHatchGraph.removeVertex(vertex);
    	nonPathVertices.push(vertex);
      for (let edge of edgeList) {
        simplifiedHatchGraph.removeEdge(vertex, edge.vertex);
      }
      simplifiedHatchGraph.vertices.splice(simplifiedHatchGraph.vertices.findIndex((v) => v === vertex), 1);
    }
  }
  for (let v of nonPathVertices) {
    delete simplifiedHatchGraph.edges[v];
  }
  
  // draw the simplified graph
  // stroke(0);
  // for (let [currVertex, edgeList] of Object.entries(simplifiedHatchGraph.edges)) {
  //   let currRowIndex = currVertex.split("-")[0];
  //   let currSegmentIndex = currVertex.split("-")[1];
  //   let currLineSegment = hatchLineSegmentRows[currRowIndex][currSegmentIndex];
  //   for (let edge of edgeList) {
  //     let nextRowIndex = edge.vertex.split("-")[0];
  //     let nextSegmentIndex = edge.vertex.split("-")[1];
  //     let nextLineSegment = hatchLineSegmentRows[nextRowIndex][nextSegmentIndex];
  //     let currLineSegmentMidPoint = currLineSegment.start.position.add(currLineSegment.end.position).multiply(0.5);
  //     let nextLineSegmentMidPoint = nextLineSegment.start.position.add(nextLineSegment.end.position).multiply(0.5);
  //     line(currLineSegmentMidPoint.x, currLineSegmentMidPoint.y, nextLineSegmentMidPoint.x, nextLineSegmentMidPoint.y);
  //   }
  // }
  
  let connectedComponents = simplifiedHatchGraph.connectedComponents().map((c) => {
  	return c.map((v) => {
			return {
				vertex: v,
				rowIndex: parseInt(v.split("-")[0]),
				segmentIndex: parseInt(v.split("-")[1])
			};
  	}).sort((a, b) => { return a.rowIndex < b.rowIndex ? 1 : -1; })
  });

  let contractedGraph = new Stitch.Math.Graph();
  for (let i = 0; i < nonPathVertices.length; i++) contractedGraph.addVertex(i);
  for (let i = 0; i < connectedComponents.length; i++) contractedGraph.addVertex(nonPathVertices.length + i);

  for (let i = 0; i < nonPathVertices.length; i++) {
  	for (let j = i + 1; j < nonPathVertices.length; j++) {
  		if (hatchGraph.findEdgeIndex(nonPathVertices[i], nonPathVertices[j]) >= 0) {
  			contractedGraph.addEdge(i, j);
  		}
  	}
  }
  for (let i = 0; i < connectedComponents.length; i++) {
  	for (let j = 0; j < nonPathVertices.length; j++) {
  		if (hatchGraph.findEdgeIndex(connectedComponents[i][0].vertex, nonPathVertices[j]) >= 0) {
  			contractedGraph.addEdge(nonPathVertices.length + i, j);
  		}
  		if (connectedComponents[i].length > 1) {
  			if (hatchGraph.findEdgeIndex(connectedComponents[i][connectedComponents[i].length - 1].vertex, nonPathVertices[j]) >= 0) {
	  			contractedGraph.addEdge(nonPathVertices.length + i, j);
	  		}
  		}
  	}
  }

  for (let [vertex, edgeList] of Object.entries(contractedGraph.edges)) {
  	if (edgeList.length === 0) {
  		let vIndex = contractedGraph.vertices.findIndex((v) => v === vertex);
  		if (vIndex > -1) contractedGraph.vertices.splice(vIndex, 1);
  		delete contractedGraph.edges[vertex];
  	}
  }

  // draw the contracted graph
  push();
  fill(255, 0, 0);
  stroke(0);
  // for (let i = 0; i < contractedGraph.vertices.length; i++) {
  for (let i of contractedGraph.vertices) {
  	let vertex;
  	if (i < nonPathVertices.length) {
  		vertex = nonPathVertices[i];
  	} else {
  		vertex = connectedComponents[i - nonPathVertices.length][Math.floor(0.5 * connectedComponents[i - nonPathVertices.length].length)].vertex;
  	}
  	let lineSegment = hatchLineSegmentRows[vertex.split("-")[0]][vertex.split("-")[1]];
  	let midpoint = lineSegment.start.position.add(lineSegment.end.position).multiply(0.5);
  	circle(midpoint.x, midpoint.y, 5);
  	for (let neighbor of contractedGraph.edges[i]) {
  		let nVertex;
  		if (parseInt(neighbor.vertex) < nonPathVertices.length) {
  			nVertex = nonPathVertices[parseInt(neighbor.vertex)];
  		} else {
  			nVertex = connectedComponents[parseInt(neighbor.vertex) - nonPathVertices.length][Math.floor(0.5 * connectedComponents[parseInt(neighbor.vertex) - nonPathVertices.length].length)].vertex;
  		}
	  	let nLineSegment = hatchLineSegmentRows[nVertex.split("-")[0]][nVertex.split("-")[1]];
	  	let nMidpoint = nLineSegment.start.position.add(nLineSegment.end.position).multiply(0.5);
  		line(midpoint.x, midpoint.y, nMidpoint.x, nMidpoint.y);
  	}
  }
  pop();

	let path = contractedGraph.tsp();
	if (frameCount === 1) console.log(path);

			}
		</script>
	</body>

</html>